"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "NpmScriptRunner", {
    enumerable: true,
    get: function() {
        return NpmScriptRunner;
    }
});
const _fs = require("fs");
const _path = require("path");
const _promises = require("fs/promises");
const _child_process = require("child_process");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class NpmScriptRunner {
    getNpmArgs(task, taskTargs) {
        const extraArgs = taskTargs.length > 0 ? [
            "--",
            ...taskTargs
        ] : [];
        return [
            "run",
            task,
            ...extraArgs
        ];
    }
    async hasNpmScript(target) {
        const task = target.options?.script ?? target.task;
        const packageJsonPath = (0, _path.join)(target.cwd, "package.json");
        const packageJson = JSON.parse(await (0, _promises.readFile)(packageJsonPath, "utf8"));
        return !!packageJson.scripts?.[task];
    }
    validateOptions(options) {
        if (!(0, _fs.existsSync)(options.npmCmd)) {
            throw new Error(`NPM Script Runner: ${this.options.npmCmd} does not exist`);
        }
    }
    async shouldRun(target) {
        // By convention, do not run anything if there is no script for this task defined in package.json (counts as "success")
        return await this.hasNpmScript(target);
    }
    async run(runOptions) {
        const { target , weight , abortSignal  } = runOptions;
        const { nodeOptions , npmCmd , taskArgs  } = this.options;
        const task = target.options?.script ?? target.task;
        let childProcess;
        /**
     * Handling abort signal from the abort controller. Gracefully kills the process,
     * will be handled by exit handler separately to resolve the promise.
     */ if (abortSignal) {
            if (abortSignal.aborted) {
                return;
            }
            const abortSignalHandler = ()=>{
                abortSignal.removeEventListener("abort", abortSignalHandler);
                if (childProcess && !childProcess.killed) {
                    const pid = childProcess.pid;
                    process.stdout.write(`Abort signal detected, attempting to killing process id ${pid}\n`);
                    childProcess.kill("SIGTERM");
                    // wait for "gracefulKillTimeout" to make sure everything is terminated via SIGKILL
                    const t = setTimeout(()=>{
                        if (childProcess && !childProcess.killed) {
                            childProcess.kill("SIGKILL");
                        }
                    }, NpmScriptRunner.gracefulKillTimeout);
                    // Remember that even this timeout needs to be unref'ed, otherwise the process will hang due to this timeout
                    if (t.unref) {
                        t.unref();
                    }
                }
            };
            abortSignal.addEventListener("abort", abortSignalHandler);
        }
        /**
     * Actually spawn the npm client to run the task
     */ const npmRunArgs = this.getNpmArgs(task, taskArgs);
        const npmRunNodeOptions = [
            nodeOptions,
            target.options?.nodeOptions
        ].filter((str)=>str).join(" ");
        await new Promise((resolve, reject)=>{
            childProcess = (0, _child_process.spawn)(npmCmd, npmRunArgs, {
                cwd: target.cwd,
                stdio: [
                    "inherit",
                    "pipe",
                    "pipe"
                ],
                env: {
                    ...process.env,
                    ...process.stdout.isTTY && {
                        FORCE_COLOR: "1"
                    },
                    ...npmRunNodeOptions && {
                        NODE_OPTIONS: npmRunNodeOptions
                    },
                    LAGE_PACKAGE_NAME: target.packageName,
                    LAGE_TASK: target.task,
                    LAGE_WEIGHT: String(weight)
                }
            });
            let exitHandled = false;
            const handleChildProcessExit = (code)=>{
                childProcess?.off("exit", handleChildProcessExit);
                childProcess?.off("error", handleChildProcessExit);
                if (exitHandled) {
                    return;
                }
                exitHandled = true;
                childProcess?.stdout?.destroy();
                childProcess?.stderr?.destroy();
                childProcess?.stdin?.destroy();
                if (code === 0) {
                    return resolve();
                }
                reject(new Error(`NPM Script Runner: ${npmCmd} ${npmRunArgs.join(" ")} exited with code ${code}`));
            };
            const { pid  } = childProcess;
            process.stdout.write(`Running ${[
                npmCmd,
                ...npmRunArgs
            ].join(" ")}, pid: ${pid}\n`);
            const stdout = childProcess.stdout;
            const stderr = childProcess.stderr;
            stdout.pipe(process.stdout);
            stderr.pipe(process.stderr);
            childProcess.on("exit", handleChildProcessExit);
            childProcess.on("error", ()=>handleChildProcessExit(1));
        });
    }
    constructor(options){
        _define_property(this, "options", void 0);
        this.options = options;
        this.validateOptions(options);
    }
}
_define_property(NpmScriptRunner, "gracefulKillTimeout", 2500);
