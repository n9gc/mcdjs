/// <reference types="node" />
import * as fs from 'fs';
import 'promise-snake';
/**
 * Lethal Build
 * @version 1.3.2
 * @license GPL-3.0-or-later
 * @link https://github.com/E0SelmY4V/lethal-build
 */
declare function initer(dir: string): initer.Opn;
declare namespace initer {
    var _a: typeof initer;
    export { _a as default };
}
declare namespace initer {
    type Will<T> = T | PromiseLike<T>;
    const OpnList: {
        [dir: string]: Opn;
    };
    const isRegExp: (n: RegExp | readonly any[]) => n is RegExp;
    const ignoreList: string[];
    const isAbs: (fname: string) => boolean;
    const noSep: (fname: string) => string;
    const rep: (n: string, f: string, t: string) => string;
    const reps: (n: string, f: string[], t: string[]) => string;
    const regSign: readonly string[];
    const goodReg: (text: string) => string;
    class Opn {
        constructor(dir: string);
        dir: string;
        comp: (fname: string) => string;
        compWill: (fname: Will<string>) => Promise<string>;
        file2reg: (fname: string) => RegExp;
        goodReg: (text: string) => string;
        private cmtMem;
        cmt: (cmtFile: Will<string>, br?: string) => Promise<string>;
        get ignoreList(): string[];
        set ignoreList(n: string[]);
        walk: (dir?: Will<string>, matched?: Will<Will<string>[]>) => Promise<Will<string>[]>;
        private sigMatch;
        match: (regsWill: Will<RegExp | string | Will<string | RegExp>[]>, dir?: Will<string>) => Promise<string[]>;
        mergeOut: (files: Will<Will<string>[] | RegExp>, out: fs.WriteStream) => () => Promise<fs.WriteStream>;
        tempFileId: number;
        outFS: (infosWill: Will<[0 | 1 | boolean, Will<string>][]>, outWill: Will<string | fs.WriteStream>) => () => Promise<void>;
        cps: (opns: Will<Will<[Will<string>, Will<string>]>[] | [Will<string>, Will<string>]>) => () => Promise<void>;
        dels: (files: Will<Will<string | RegExp>[] | RegExp | string>) => () => Promise<void>;
        mvs: (opnsWill: Will<Will<[Will<string>, Will<string>]>[] | [Will<string>, Will<string>]>) => () => Promise<void>;
        mkdir: (dir: Will<string> | Will<Will<string>[]>) => () => Promise<void>;
        exec: (cmd: Will<string>) => () => Promise<void>;
        judge: (...values: ((() => boolean) | Will<boolean>)[]) => () => Promise<void>;
        snake: (...opns: Will<() => PromiseLike<any>>[]) => Promise<any>;
        log: <T>(...msgWill: T[]) => () => Promise<void>;
        private tempTimeId;
        private tempList;
        private tempLast;
        private timeStarts;
        private timeCallbacks;
        private timePromises;
        getHrtime: (timeArr?: [number, number]) => number;
        timeStart: (name?: string | null, timeArr?: undefined) => () => Promise<void>;
        timeEnd: (name?: string | null) => () => Promise<void>;
        time: (name?: string) => Promise<number>;
        initer: typeof initer;
    }
}
export = initer;
